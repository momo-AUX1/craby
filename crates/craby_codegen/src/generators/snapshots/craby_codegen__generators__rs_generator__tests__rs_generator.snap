---
source: crates/craby_codegen/src/generators/rs_generator.rs
expression: result
---
./crates/lib/src/lib.rs
#[rustfmt::skip]

#[macro_use]
pub(crate) mod macros;

pub(crate) mod ffi;
pub(crate) mod generated;
pub(crate) mod types;

pub(crate) mod craby_test_impl;

./crates/lib/src/ffi.rs
#[rustfmt::skip]
use crate::craby_test_impl::*;
use crate::generated::*;

use bridging::*;

#[cxx::bridge(namespace = "craby::bridging")]
pub mod bridging {
    struct NullableNumber {
        null: bool,
        val: f64,
    }

    struct NullableString {
        null: bool,
        val: String
    }

    struct SubObject {
        a: NullableString,
        b: f64,
        c: bool,
    }

    struct NullableSubObject {
        null: bool,
        val: SubObject
    }

    struct TestObject {
        foo: String,
        bar: f64,
        baz: bool,
        sub: NullableSubObject,
    }

    enum MyEnum {
        Foo,
        Bar,
        Baz,
    }

    enum SwitchState {
        Off,
        On,
    }

    extern "Rust" {
        #[cxx_name = "numericMethod"]
        fn craby_test_numeric_method(id_: usize, arg: f64) -> Result<f64>;

        #[cxx_name = "booleanMethod"]
        fn craby_test_boolean_method(id_: usize, arg: bool) -> Result<bool>;

        #[cxx_name = "stringMethod"]
        fn craby_test_string_method(id_: usize, arg: String) -> Result<String>;

        #[cxx_name = "objectMethod"]
        fn craby_test_object_method(id_: usize, arg: TestObject) -> Result<TestObject>;

        #[cxx_name = "arrayMethod"]
        fn craby_test_array_method(id_: usize, arg: Vec<f64>) -> Result<Vec<f64>>;

        #[cxx_name = "enumMethod"]
        fn craby_test_enum_method(id_: usize, arg0: MyEnum, arg1: SwitchState) -> Result<String>;

        #[cxx_name = "nullableMethod"]
        fn craby_test_nullable_method(id_: usize, arg: NullableNumber) -> Result<NullableNumber>;

        #[cxx_name = "promiseMethod"]
        fn craby_test_promise_method(id_: usize, arg: f64) -> Result<f64>;
    }

    #[namespace = "craby::signals"]
    unsafe extern "C++" {
        include!("signals.h");

        type SignalManager;

        fn emit(self: &SignalManager, id: usize, name: &str);
        #[rust_name = "get_signal_manager"]
        fn getSignalManager() -> &'static SignalManager;
    }
}

fn craby_test_numeric_method(id_: usize, arg: f64) -> Result<f64, anyhow::Error> {
    catch_panic!({
        let it = CrabyTest::new(id_);
        let ret = it.numeric_method(arg);
        ret
    })
}

fn craby_test_boolean_method(id_: usize, arg: bool) -> Result<bool, anyhow::Error> {
    catch_panic!({
        let it = CrabyTest::new(id_);
        let ret = it.boolean_method(arg);
        ret
    })
}

fn craby_test_string_method(id_: usize, arg: String) -> Result<String, anyhow::Error> {
    catch_panic!({
        let it = CrabyTest::new(id_);
        let ret = it.string_method(arg);
        ret
    })
}

fn craby_test_object_method(id_: usize, arg: TestObject) -> Result<TestObject, anyhow::Error> {
    catch_panic!({
        let it = CrabyTest::new(id_);
        let ret = it.object_method(arg);
        ret
    })
}

fn craby_test_array_method(id_: usize, arg: Vec<f64>) -> Result<Vec<f64>, anyhow::Error> {
    catch_panic!({
        let it = CrabyTest::new(id_);
        let ret = it.array_method(arg);
        ret
    })
}

fn craby_test_enum_method(id_: usize, arg0: MyEnum, arg1: SwitchState) -> Result<String, anyhow::Error> {
    catch_panic!({
        let it = CrabyTest::new(id_);
        let ret = it.enum_method(arg0, arg1);
        ret
    })
}

fn craby_test_nullable_method(id_: usize, arg: NullableNumber) -> Result<NullableNumber, anyhow::Error> {
    catch_panic!({
        let it = CrabyTest::new(id_);
        let ret = it.nullable_method(arg.into());
        ret.into()
    })
}

fn craby_test_promise_method(id_: usize, arg: f64) -> Result<f64, anyhow::Error> {
    catch_panic!({
        let it = CrabyTest::new(id_);
        let ret = it.promise_method(arg);
        ret
    }).and_then(|r| r)
}

./crates/lib/src/generated.rs
#[rustfmt::skip]
use crate::ffi::bridging::*;
use crate::types::*;

pub trait CrabyTestSpec {
    fn new(id: usize) -> Self;
    fn id(&self) -> usize;
    fn emit(&self, signal_name: CrabyTestSignal) {
        let manager = crate::ffi::bridging::get_signal_manager();
        match signal_name {
            CrabyTestSignal::OnSignal => manager.emit(self.id(), "onSignal"),
        }
    }
    fn numeric_method(&self, arg: Number) -> Number;
    fn boolean_method(&self, arg: Boolean) -> Boolean;
    fn string_method(&self, arg: String) -> String;
    fn object_method(&self, arg: TestObject) -> TestObject;
    fn array_method(&self, arg: Array<Number>) -> Array<Number>;
    fn enum_method(&self, arg0: MyEnum, arg1: SwitchState) -> String;
    fn nullable_method(&self, arg: Nullable<Number>) -> Nullable<Number>;
    fn promise_method(&self, arg: Number) -> Promise<Number>;
}

pub enum CrabyTestSignal {
    OnSignal,
}

impl Default for MyEnum {
    fn default() -> Self {
        MyEnum::Foo
    }
}

impl Default for NullableString {
    fn default() -> Self {
        NullableString {
            null: true,
            val: String::default(),
        }
    }
}

impl From<NullableString> for Nullable<String> {
    fn from(val: NullableString) -> Self {
        Nullable::new(if val.null { None } else { Some(val.val) })
    }
}

impl From<Nullable<String>> for NullableString {
    fn from(val: Nullable<String>) -> Self {
        let val = val.into_value();
        let null = val.is_none();
        NullableString {
            val: val.unwrap_or(String::default()),
            null,
        }
    }
}

impl Default for SubObject {
    fn default() -> Self {
        SubObject {
            a: NullableString::default(),
            b: 0.0,
            c: false
        }
    }
}

impl Default for SwitchState {
    fn default() -> Self {
        SwitchState::Off
    }
}

impl Default for NullableSubObject {
    fn default() -> Self {
        NullableSubObject {
            null: true,
            val: SubObject::default(),
        }
    }
}

impl From<NullableSubObject> for Nullable<SubObject> {
    fn from(val: NullableSubObject) -> Self {
        Nullable::new(if val.null { None } else { Some(val.val) })
    }
}

impl From<Nullable<SubObject>> for NullableSubObject {
    fn from(val: Nullable<SubObject>) -> Self {
        let val = val.into_value();
        let null = val.is_none();
        NullableSubObject {
            val: val.unwrap_or(SubObject::default()),
            null,
        }
    }
}

impl Default for TestObject {
    fn default() -> Self {
        TestObject {
            foo: String::default(),
            bar: 0.0,
            baz: false,
            sub: NullableSubObject::default()
        }
    }
}

impl Default for NullableNumber {
    fn default() -> Self {
        NullableNumber {
            null: true,
            val: 0.0,
        }
    }
}

impl From<NullableNumber> for Nullable<Number> {
    fn from(val: NullableNumber) -> Self {
        Nullable::new(if val.null { None } else { Some(val.val) })
    }
}

impl From<Nullable<Number>> for NullableNumber {
    fn from(val: Nullable<Number>) -> Self {
        let val = val.into_value();
        let null = val.is_none();
        NullableNumber {
            val: val.unwrap_or(0.0),
            null,
        }
    }
}

./crates/lib/src/types.rs
#[rustfmt::skip]
pub type Boolean = bool;
pub type Number = f64;
pub type String = std::string::String;
pub type Array<T> = std::vec::Vec<T>;
pub type Promise<T> = std::result::Result<T, anyhow::Error>;
pub type Void = ();

pub mod promise {
    use super::Promise;

    pub fn resolve<T>(val: T) -> Promise<T> {
        Ok(val)
    }

    pub fn reject<T>(err: impl AsRef<str>) -> Promise<T> {
        Err(anyhow::anyhow!(err.as_ref().to_string()))
    }
}

pub struct Nullable<T> {
    val: Option<T>,
}

impl<T> Nullable<T> {
    pub fn new(val: Option<T>) -> Self {
        Nullable { val }
    }

    pub fn some(val: T) -> Self {
        Nullable { val: Some(val) }
    }

    pub fn none() -> Self {
        Nullable { val: None }
    }

    pub fn value(mut self, val: T) -> Self {
        self.val = Some(val);
        self
    }

    pub fn value_of(&self) -> Option<&T> {
        self.val.as_ref()
    }

    pub fn into_value(self) -> Option<T> {
        self.val
    }
}

./crates/lib/src/macros.rs
#[macro_export]
macro_rules! throw {
    ($($arg:tt)*) => {
        panic!($($arg)*)
    };
}

#[macro_export]
macro_rules! catch_panic {
    ($expr:expr) => {
        std::panic::catch_unwind(|| $expr).map_err(|e| {
            let msg = if let Some(s) = e.downcast_ref::<&str>() {
                (*s).to_string()
            } else if let Some(s) = e.downcast_ref::<String>() {
                s.clone()
            } else {
                "Unknown panic occurred".to_string()
            };
            anyhow::anyhow!(msg)
        })
    };
}

./crates/lib/src/craby_test_impl.rs
use crate::ffi::bridging::*;
use crate::generated::*;
use crate::types::*;

pub struct CrabyTest {
    id: usize,
}

impl CrabyTestSpec for CrabyTest {
    fn new(id: usize) -> Self {
        CrabyTest { id }
    }

    fn id(&self) -> usize {
        self.id
    }

    fn numeric_method(&self, arg: Number) -> Number {
        unimplemented!();
    }

    fn boolean_method(&self, arg: Boolean) -> Boolean {
        unimplemented!();
    }

    fn string_method(&self, arg: String) -> String {
        unimplemented!();
    }

    fn object_method(&self, arg: TestObject) -> TestObject {
        unimplemented!();
    }

    fn array_method(&self, arg: Array<Number>) -> Array<Number> {
        unimplemented!();
    }

    fn enum_method(&self, arg0: MyEnum, arg1: SwitchState) -> String {
        unimplemented!();
    }

    fn nullable_method(&self, arg: Nullable<Number>) -> Nullable<Number> {
        unimplemented!();
    }

    fn promise_method(&self, arg: Number) -> Promise<Number> {
        unimplemented!();
    }
}
